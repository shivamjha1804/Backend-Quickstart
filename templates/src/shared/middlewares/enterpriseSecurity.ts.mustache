{{#typescript}}import { Request, Response, NextFunction } from 'express';{{/typescript}}{{^typescript}}const express = require('express');{{/typescript}}
{{#typescript}}import rateLimit from 'express-rate-limit';{{/typescript}}{{^typescript}}const rateLimit = require('express-rate-limit');{{/typescript}}
{{#typescript}}import slowDown from 'express-slow-down';{{/typescript}}{{^typescript}}const slowDown = require('express-slow-down');{{/typescript}}
{{#typescript}}import { body, validationResult, ValidationError } from 'express-validator';{{/typescript}}{{^typescript}}const { body, validationResult } = require('express-validator');{{/typescript}}
{{#typescript}}import hpp from 'hpp';{{/typescript}}{{^typescript}}const hpp = require('hpp');{{/typescript}}
{{#typescript}}import { config } from '../../config';{{/typescript}}{{^typescript}}const { config } = require('../../config');{{/typescript}}
{{#typescript}}import { logger } from '../../core/utils/logger';{{/typescript}}{{^typescript}}const { logger } = require('../../core/utils/logger');{{/typescript}}

/**
 * Enterprise-grade security middleware stack
 */

/**
 * Advanced request sanitization
 */
{{#typescript}}export const advancedSanitization = (req: Request, res: Response, next: NextFunction): void => {{/typescript}}{{^typescript}}const advancedSanitization = (req, res, next) => {{/typescript}}{
  // Request size validation
  const maxSize = parseInt(config.security?.maxRequestSize || '10mb');
  if (req.get('Content-Length') && parseInt(req.get('Content-Length')!) > maxSize) {
    return res.status(413).json({
      success: false,
      error: {
        message: 'Request too large',
        statusCode: 413
      }
    });
  }

  // Content-Type validation for POST/PUT/PATCH
  if (['POST', 'PUT', 'PATCH'].includes(req.method)) {
    const contentType = req.get('Content-Type');
    const allowedTypes = [
      'application/json',
      'application/x-www-form-urlencoded',
      'multipart/form-data'
    ];
    
    if (contentType && !allowedTypes.some(type => contentType.includes(type))) {
      return res.status(415).json({
        success: false,
        error: {
          message: 'Unsupported media type',
          statusCode: 415
        }
      });
    }
  }

  // Remove potentially dangerous headers
  delete req.headers['x-forwarded-host'];
  delete req.headers['x-cluster-client-ip'];
  
  next();
};

/**
 * Advanced XSS Protection
 */
{{#typescript}}export const advancedXssProtection = (req: Request, res: Response, next: NextFunction): void => {{/typescript}}{{^typescript}}const advancedXssProtection = (req, res, next) => {{/typescript}}{
  const xss = require('xss');
  
  // Deep sanitize request body
  function sanitizeObject(obj{{#typescript}}: any{{/typescript}}){{#typescript}}: any{{/typescript}} {
    if (typeof obj === 'string') {
      return xss(obj, {
        whiteList: {}, // No HTML tags allowed
        stripIgnoreTag: true,
        stripIgnoreTagBody: ['script']
      });
    } else if (Array.isArray(obj)) {
      return obj.map(item => sanitizeObject(item));
    } else if (obj && typeof obj === 'object') {
      const sanitized{{#typescript}}: any{{/typescript}} = {};
      for (const key in obj) {
        sanitized[key] = sanitizeObject(obj[key]);
      }
      return sanitized;
    }
    return obj;
  }

  if (req.body) {
    req.body = sanitizeObject(req.body);
  }

  if (req.query) {
    req.query = sanitizeObject(req.query);
  }

  next();
};

/**
 * SQL Injection Protection
 */
{{#typescript}}export const sqlInjectionProtection = (req: Request, res: Response, next: NextFunction): void => {{/typescript}}{{^typescript}}const sqlInjectionProtection = (req, res, next) => {{/typescript}}{
  const sqlPatterns = [
    /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION|SCRIPT)\b)/i,
    /(--|#|\/\*|\*\/)/,
    /(\b(OR|AND)\b.*=.*)/i,
    /('|(\\')|(;)|(\\x)|(\\0))/
  ];

  function checkForSqlInjection(obj{{#typescript}}: any{{/typescript}}, path = ''){{#typescript}}: boolean{{/typescript}} {
    if (typeof obj === 'string') {
      for (const pattern of sqlPatterns) {
        if (pattern.test(obj)) {
          logger.warn('Potential SQL injection attempt detected', {
            path,
            value: obj,
            ip: req.ip,
            userAgent: req.get('User-Agent')
          });
          return true;
        }
      }
    } else if (Array.isArray(obj)) {
      for (let i = 0; i < obj.length; i++) {
        if (checkForSqlInjection(obj[i], `${path}[${i}]`)) {
          return true;
        }
      }
    } else if (obj && typeof obj === 'object') {
      for (const key in obj) {
        if (checkForSqlInjection(obj[key], path ? `${path}.${key}` : key)) {
          return true;
        }
      }
    }
    return false;
  }

  if (checkForSqlInjection(req.body, 'body') || 
      checkForSqlInjection(req.query, 'query') || 
      checkForSqlInjection(req.params, 'params')) {
    
    return res.status(400).json({
      success: false,
      error: {
        message: 'Invalid request format',
        statusCode: 400
      }
    });
  }

  next();
};

/**
 * Request Fingerprinting for Security
 */
{{#typescript}}export const requestFingerprinting = (req: Request, res: Response, next: NextFunction): void => {{/typescript}}{{^typescript}}const requestFingerprinting = (req, res, next) => {{/typescript}}{
  const crypto = require('crypto');
  
  // Generate request fingerprint
  const fingerprintData = [
    req.get('User-Agent') || '',
    req.get('Accept-Language') || '',
    req.get('Accept-Encoding') || '',
    req.ip || '',
    req.connection.remotePort || ''
  ].join('|');

  const fingerprint = crypto
    .createHash('sha256')
    .update(fingerprintData)
    .digest('hex');

  // Add to request for later use
  {{#typescript}}(req as any).fingerprint = fingerprint;{{/typescript}}{{^typescript}}req.fingerprint = fingerprint;{{/typescript}}

  // Rate limiting by fingerprint
  {{#typescript}}(req as any).rateLimitKey = fingerprint;{{/typescript}}{{^typescript}}req.rateLimitKey = fingerprint;{{/typescript}}

  next();
};

/**
 * Advanced Rate Limiting with Tiered Protection
 */
{{#typescript}}export const createAdvancedRateLimit = (options: {
  windowMs?: number;
  maxRequests?: number;
  skipSuccessfulRequests?: boolean;
  keyGenerator?: (req: Request) => string;
}) => {{/typescript}}{{^typescript}}const createAdvancedRateLimit = (options) => {{/typescript}}{
  const {
    windowMs = 15 * 60 * 1000, // 15 minutes
    maxRequests = 100,
    skipSuccessfulRequests = false,
    keyGenerator
  } = options;

  return rateLimit({
    windowMs,
    max: maxRequests,
    skipSuccessfulRequests,
    keyGenerator: keyGenerator || ((req{{#typescript}}: Request{{/typescript}}) => {
      // Use fingerprint if available, fallback to IP
      return {{#typescript}}(req as any).fingerprint ||{{/typescript}}{{^typescript}}req.fingerprint ||{{/typescript}} req.ip;
    }),
    handler: (req, res) => {
      logger.warn('Rate limit exceeded', {
        ip: req.ip,
        fingerprint: {{#typescript}}(req as any).fingerprint{{/typescript}}{{^typescript}}req.fingerprint{{/typescript}},
        userAgent: req.get('User-Agent'),
        path: req.path
      });

      res.status(429).json({
        success: false,
        error: {
          message: 'Too many requests, please try again later',
          statusCode: 429,
          retryAfter: Math.round(windowMs / 1000)
        }
      });
    },
    standardHeaders: true,
    legacyHeaders: false
  });
};

/**
 * Request Slowdown (Gradual delay before rate limiting)
 */
{{#typescript}}export const requestSlowDown = slowDown({
  windowMs: 5 * 60 * 1000, // 5 minutes
  delayAfter: 50, // Allow 50 requests per windowMs without delay
  delayMs: 100, // Add 100ms delay per request after delayAfter
  maxDelayMs: 2000, // Max delay of 2 seconds
  keyGenerator: (req: Request) => (req as any).fingerprint || req.ip
});{{/typescript}}{{^typescript}}const requestSlowDown = slowDown({
  windowMs: 5 * 60 * 1000, // 5 minutes
  delayAfter: 50, // Allow 50 requests per windowMs without delay
  delayMs: 100, // Add 100ms delay per request after delayAfter
  maxDelayMs: 2000, // Max delay of 2 seconds
  keyGenerator: (req) => req.fingerprint || req.ip
});{{/typescript}}

/**
 * HTTP Parameter Pollution Protection
 */
{{#typescript}}export const parameterPollutionProtection = hpp({
  whitelist: ['tags', 'categories'] // Allow arrays for these parameters
});{{/typescript}}{{^typescript}}const parameterPollutionProtection = hpp({
  whitelist: ['tags', 'categories'] // Allow arrays for these parameters
});{{/typescript}}

/**
 * Request Validation Chain
 */
{{#typescript}}export const validateRequest = (validations: any[]) => {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {{/typescript}}{{^typescript}}const validateRequest = (validations) => {
  return async (req, res, next) => {{/typescript}}{
    // Run all validations
    await Promise.all(validations.map((validation{{#typescript}}: any{{/typescript}}) => validation.run(req)));

    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      const errorDetails = errors.array().map((error{{#typescript}}: ValidationError{{/typescript}}) => ({
        field: error.param,
        message: error.msg,
        value: error.value
      }));

      logger.warn('Request validation failed', {
        errors: errorDetails,
        ip: req.ip,
        path: req.path
      });

      return res.status(400).json({
        success: false,
        error: {
          message: 'Validation failed',
          statusCode: 400,
          details: errorDetails
        }
      });
    }

    next();
  };
};

/**
 * Security Headers Enhancement
 */
{{#typescript}}export const enhancedSecurityHeaders = (req: Request, res: Response, next: NextFunction): void => {{/typescript}}{{^typescript}}const enhancedSecurityHeaders = (req, res, next) => {{/typescript}}{
  // Additional security headers
  res.set({
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block',
    'Referrer-Policy': 'strict-origin-when-cross-origin',
    'Permissions-Policy': 'geolocation=(), microphone=(), camera=()',
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains; preload',
    'Content-Security-Policy': "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'",
    'X-Permitted-Cross-Domain-Policies': 'none',
    'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
    'Pragma': 'no-cache',
    'Expires': '0'
  });

  next();
};

/**
 * Request ID and Correlation Tracking
 */
{{#typescript}}export const requestTracking = (req: Request, res: Response, next: NextFunction): void => {{/typescript}}{{^typescript}}const requestTracking = (req, res, next) => {{/typescript}}{
  const crypto = require('crypto');
  
  // Generate unique request ID
  const requestId = req.get('X-Request-ID') || crypto.randomUUID();
  const correlationId = req.get('X-Correlation-ID') || crypto.randomUUID();

  // Add to request for logging
  {{#typescript}}(req as any).requestId = requestId;
  (req as any).correlationId = correlationId;{{/typescript}}{{^typescript}}req.requestId = requestId;
  req.correlationId = correlationId;{{/typescript}}

  // Add to response headers
  res.set({
    'X-Request-ID': requestId,
    'X-Correlation-ID': correlationId
  });

  next();
};

{{^typescript}}module.exports = {
  advancedSanitization,
  advancedXssProtection,
  sqlInjectionProtection,
  requestFingerprinting,
  createAdvancedRateLimit,
  requestSlowDown,
  parameterPollutionProtection,
  validateRequest,
  enhancedSecurityHeaders,
  requestTracking
};{{/typescript}}