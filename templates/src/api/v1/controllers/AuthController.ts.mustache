{{#authentication}}
{{#typescript}}
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import { config } from '../../../config';
import { logger } from '../../../core/utils/logger';
{{/typescript}}

{{^typescript}}
const { Request, Response, NextFunction } = require('express');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const { config } = require('../../../config');
const { logger } = require('../../../core/utils/logger');
{{/typescript}}

{{#typescript}}
{{^mongodb}}
import { User } from '../../../core/database/models/User';
import { Op } from 'sequelize';
{{/mongodb}}
{{#mongodb}}
import User from '../../../core/database/models/UserMongo';
{{/mongodb}}
{{/typescript}}

{{^typescript}}
{{^mongodb}}
const { User } = require('../../../core/database/models/User');
const { Op } = require('sequelize');
{{/mongodb}}
{{#mongodb}}
const User = require('../../../core/database/models/UserMongo');
{{/mongodb}}
{{/typescript}}

{{#typescript}}interface AuthenticatedRequest extends Request {
  user?: any;
}{{/typescript}}

{{#typescript}}
export class AuthController {
{{/typescript}}

{{^typescript}}
class AuthController {
{{/typescript}}
  /**
   * Register a new user
   */
  {{#typescript}}async register(req: Request, res: Response, next: NextFunction): Promise<void>{{/typescript}}{{^typescript}}async register(req, res, next){{/typescript}} {
    try {
      const { email, password, firstName, lastName } = req.body;

      // Check if user already exists
      {{^mongodb}}const existingUser = await User.findOne({ where: { email } });{{/mongodb}}
      {{#mongodb}}const existingUser = await User.findOne({ email });{{/mongodb}}

      if (existingUser) {
        res.status(409).json({
          success: false,
          error: {
            message: 'User with this email already exists',
            statusCode: 409
          }
        });
        return;
      }

      // Create new user
      const userData = {
        email,
        password,
        firstName,
        lastName,
        {{#mongodb}}emailVerificationToken: crypto.randomBytes(32).toString('hex'){{/mongodb}}
      };

      {{^mongodb}}const user = await User.create(userData);{{/mongodb}}
      {{#mongodb}}const user = new User(userData);
      await user.save();{{/mongodb}}

      // Generate tokens
      const accessToken = this.generateAccessToken(user);
      const refreshToken = this.generateRefreshToken(user);

      logger.info(`New user registered: ${email}`);

      res.status(201).json({
        success: true,
        data: {
          user: this.sanitizeUser(user),
          accessToken,
          refreshToken
        }
      });

    } catch (error) {
      logger.error('Registration error:', error);
      next(error);
    }
  }

  /**
   * Login user
   */
  {{#typescript}}async login(req: Request, res: Response, next: NextFunction): Promise<void>{{/typescript}}{{^typescript}}async login(req, res, next){{/typescript}} {
    try {
      const { email, password } = req.body;

      // Find user with password field
      {{^mongodb}}const user = await User.findOne({ 
        where: { email },
        attributes: { include: ['password'] }
      });{{/mongodb}}
      {{#mongodb}}const user = await User.findOne({ email }).select('+password');{{/mongodb}}

      if (!user) {
        res.status(401).json({
          success: false,
          error: {
            message: 'Invalid email or password',
            statusCode: 401
          }
        });
        return;
      }

      // Check password
      const isPasswordValid = await user.comparePassword(password);

      if (!isPasswordValid) {
        res.status(401).json({
          success: false,
          error: {
            message: 'Invalid email or password',
            statusCode: 401
          }
        });
        return;
      }

      // Check if user is active
      if (!user.isActive) {
        res.status(401).json({
          success: false,
          error: {
            message: 'Account is deactivated',
            statusCode: 401
          }
        });
        return;
      }

      // Update last login
      {{^mongodb}}await user.update({ lastLoginAt: new Date() });{{/mongodb}}
      {{#mongodb}}user.lastLoginAt = new Date();
      await user.save();{{/mongodb}}

      // Generate tokens
      const accessToken = this.generateAccessToken(user);
      const refreshToken = this.generateRefreshToken(user);

      logger.info(`User logged in: ${email}`);

      res.status(200).json({
        success: true,
        data: {
          user: this.sanitizeUser(user),
          accessToken,
          refreshToken
        }
      });

    } catch (error) {
      logger.error('Login error:', error);
      next(error);
    }
  }

  /**
   * Refresh access token
   */
  {{#typescript}}async refreshToken(req: Request, res: Response, next: NextFunction): Promise<void>{{/typescript}}{{^typescript}}async refreshToken(req, res, next){{/typescript}} {
    try {
      const { refreshToken } = req.body;

      if (!refreshToken) {
        res.status(401).json({
          success: false,
          error: {
            message: 'Refresh token is required',
            statusCode: 401
          }
        });
        return;
      }

      // Verify refresh token
      {{#typescript}}const decoded = jwt.verify(refreshToken, config.jwt.refreshSecret) as any;{{/typescript}}{{^typescript}}const decoded = jwt.verify(refreshToken, config.jwt.refreshSecret);{{/typescript}}

      // Find user
      {{^mongodb}}const user = await User.findByPk(decoded.id);{{/mongodb}}
      {{#mongodb}}const user = await User.findById(decoded.id);{{/mongodb}}

      if (!user || !user.isActive) {
        res.status(401).json({
          success: false,
          error: {
            message: 'Invalid refresh token',
            statusCode: 401
          }
        });
        return;
      }

      // Generate new access token
      const accessToken = this.generateAccessToken(user);

      res.status(200).json({
        success: true,
        data: {
          accessToken
        }
      });

    } catch (error) {
      logger.error('Token refresh error:', error);
      
      if (error.name === 'JsonWebTokenError' || error.name === 'TokenExpiredError') {
        res.status(401).json({
          success: false,
          error: {
            message: 'Invalid refresh token',
            statusCode: 401
          }
        });
        return;
      }

      next(error);
    }
  }

  /**
   * Logout user
   */
  {{#typescript}}async logout(req: AuthenticatedRequest, res: Response, next: NextFunction): Promise<void>{{/typescript}}{{^typescript}}async logout(req, res, next){{/typescript}} {
    try {
      // In a real-world scenario, you might want to implement a token blacklist
      // For now, we'll just send a success response
      logger.info(`User logged out: ${req.user.email}`);

      res.status(200).json({
        success: true,
        message: 'Logged out successfully'
      });

    } catch (error) {
      logger.error('Logout error:', error);
      next(error);
    }
  }

  /**
   * Verify email address
   */
  {{#typescript}}async verifyEmail(req: Request, res: Response, next: NextFunction): Promise<void>{{/typescript}}{{^typescript}}async verifyEmail(req, res, next){{/typescript}} {
    try {
      const { token } = req.body;

      {{^mongodb}}const user = await User.findOne({ 
        where: { emailVerificationToken: token }
      });{{/mongodb}}
      {{#mongodb}}const user = await User.findOne({ emailVerificationToken: token });{{/mongodb}}

      if (!user) {
        res.status(400).json({
          success: false,
          error: {
            message: 'Invalid or expired verification token',
            statusCode: 400
          }
        });
        return;
      }

      // Update user
      {{^mongodb}}await user.update({
        isEmailVerified: true,
        emailVerificationToken: null
      });{{/mongodb}}
      {{#mongodb}}user.isEmailVerified = true;
      user.emailVerificationToken = undefined;
      await user.save();{{/mongodb}}

      logger.info(`Email verified for user: ${user.email}`);

      res.status(200).json({
        success: true,
        message: 'Email verified successfully'
      });

    } catch (error) {
      logger.error('Email verification error:', error);
      next(error);
    }
  }

  /**
   * Request password reset
   */
  {{#typescript}}async forgotPassword(req: Request, res: Response, next: NextFunction): Promise<void>{{/typescript}}{{^typescript}}async forgotPassword(req, res, next){{/typescript}} {
    try {
      const { email } = req.body;

      {{^mongodb}}const user = await User.findOne({ where: { email } });{{/mongodb}}
      {{#mongodb}}const user = await User.findOne({ email });{{/mongodb}}

      if (!user) {
        // Don't reveal that user doesn't exist
        res.status(200).json({
          success: true,
          message: 'If an account with that email exists, we have sent a password reset link.'
        });
        return;
      }

      // Generate reset token
      const resetToken = crypto.randomBytes(32).toString('hex');
      const resetTokenExpiry = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

      {{^mongodb}}await user.update({
        passwordResetToken: resetToken,
        passwordResetExpiresAt: resetTokenExpiry
      });{{/mongodb}}
      {{#mongodb}}user.passwordResetToken = resetToken;
      user.passwordResetExpiresAt = resetTokenExpiry;
      await user.save();{{/mongodb}}

      // In a real application, you would send an email here
      logger.info(`Password reset requested for: ${email}`);

      res.status(200).json({
        success: true,
        message: 'If an account with that email exists, we have sent a password reset link.'
      });

    } catch (error) {
      logger.error('Forgot password error:', error);
      next(error);
    }
  }

  /**
   * Reset password
   */
  {{#typescript}}async resetPassword(req: Request, res: Response, next: NextFunction): Promise<void>{{/typescript}}{{^typescript}}async resetPassword(req, res, next){{/typescript}} {
    try {
      const { token, password } = req.body;

      {{^mongodb}}const user = await User.findOne({
        where: {
          passwordResetToken: token,
          passwordResetExpiresAt: {
            [Op.gt]: new Date()
          }
        }
      });{{/mongodb}}
      {{#mongodb}}const user = await User.findOne({
        passwordResetToken: token,
        passwordResetExpiresAt: { $gt: new Date() }
      });{{/mongodb}}

      if (!user) {
        res.status(400).json({
          success: false,
          error: {
            message: 'Invalid or expired reset token',
            statusCode: 400
          }
        });
        return;
      }

      // Update password and clear reset token
      {{^mongodb}}await user.update({
        password,
        passwordResetToken: null,
        passwordResetExpiresAt: null
      });{{/mongodb}}
      {{#mongodb}}user.password = password;
      user.passwordResetToken = undefined;
      user.passwordResetExpiresAt = undefined;
      await user.save();{{/mongodb}}

      logger.info(`Password reset completed for user: ${user.email}`);

      res.status(200).json({
        success: true,
        message: 'Password reset successfully'
      });

    } catch (error) {
      logger.error('Password reset error:', error);
      next(error);
    }
  }

  /**
   * Generate access token
   */
  {{#typescript}}private generateAccessToken(user: any): string{{/typescript}}{{^typescript}}generateAccessToken(user){{/typescript}} {
    {{#authentication}}if (!config.jwt) {
      throw new Error('JWT configuration is missing');
    }{{/authentication}}
    
    return jwt.sign(
      {
        id: user.id,
        email: user.email,
        role: user.role || 'user'
      },
      config.jwt{{#authentication}}!{{/authentication}}.secret,
      { expiresIn: config.jwt{{#authentication}}!{{/authentication}}.expiresIn }
    );
  }

  /**
   * Generate refresh token
   */
  {{#typescript}}private generateRefreshToken(user: any): string{{/typescript}}{{^typescript}}generateRefreshToken(user){{/typescript}} {
    {{#authentication}}if (!config.jwt) {
      throw new Error('JWT configuration is missing');
    }{{/authentication}}
    
    return jwt.sign(
      { id: user.id },
      config.jwt{{#authentication}}!{{/authentication}}.refreshSecret,
      { expiresIn: config.jwt{{#authentication}}!{{/authentication}}.refreshExpiresIn }
    );
  }

  /**
   * Remove sensitive fields from user object
   */
  {{#typescript}}private sanitizeUser(user: any): any{{/typescript}}{{^typescript}}sanitizeUser(user){{/typescript}} {
    const userObj = user.toJSON ? user.toJSON() : user;
    delete userObj.password;
    delete userObj.emailVerificationToken;
    delete userObj.passwordResetToken;
    delete userObj.passwordResetExpiresAt;
    return userObj;
  }
}

{{^typescript}}
module.exports = { AuthController };
{{/typescript}}
{{/authentication}}